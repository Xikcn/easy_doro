<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æƒ…æ„Ÿè¯­éŸ³åŠ©æ‰‹</title>
    <style>
        body {
         font-family: "Microsoft YaHei", sans-serif;
        background: #f0f2f5;
        margin: 0;
        padding: 10px; /* å‡å°‘å†…è¾¹è· */
        overflow: hidden; /* ç¦æ­¢é¡µé¢æ»šåŠ¨ */
        height: 100vh; /* ä½¿ç”¨è§†å£é«˜åº¦ */
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            position: relative;
        }

        #animation-canvas {
            width: 100%;
            height: 450px;
            border-radius: 8px;
            background: #000;
            margin-bottom: 20px;
        }

        .chat-container {
        height: 250px; /* ç¼©å°é«˜åº¦ */
        overflow-y: auto;
        margin-bottom: 15px; /* å‡å°‘é—´è· */
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 8px; /* å‡å°‘å†…è¾¹è· */
    }

        .message {
            margin: 10px 0;
            padding: 12px 16px;
            border-radius: 20px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }

        .user-message {
            background: #e3f2fd;
            margin-left: auto;
        }

        .ai-message {
            background: #f5f5f5;
            margin-right: auto;
        }

        .message-header {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .replay-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
            transition: opacity 0.2s;
        }

        .replay-btn:hover {
            opacity: 0.9;
        }

        .action-button {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 12px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            color: white;
            border-radius: 12px;
        }

        .record-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ff4444;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .recording .record-indicator {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .timer {
            position: fixed;
            top: 70px;
            right: 20px;
            color: #666;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
            padding: 4px 8px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="record-indicator"></div>
    <div class="timer">00:00</div>
    <div class="container">
        <canvas id="animation-canvas"></canvas>
        <div class="chat-container" id="chat-history"></div>
        <div class="loading-overlay" id="loading">
            <div>æ­£åœ¨å¤„ç†ä¸­...</div>
        </div>
        <button class="action-button" id="record-button">
            ğŸ¤ æŒ‰ä½å½•éŸ³
        </button>
    </div>

    <script>
        const API_BASE = window.location.hostname === 'localhost' ? 'http://localhost:8000' : window.location.origin;
        // è§†é¢‘æ’­æ”¾æ§åˆ¶
        const canvas = document.getElementById('animation-canvas');
        const ctx = canvas.getContext('2d');
        let currentVideo = null;
        let isRendering = false;

        // è§†é¢‘èµ„æºæ± 
const videoPool = {
    'å¼€å¿ƒ': createVideoElement(`${API_BASE}/videos/å¼€å¿ƒçš„è¯´.mp4`),
    'ä¼¤å¿ƒ': createVideoElement(`${API_BASE}/videos/ä¼¤å¿ƒçš„è¯´.mp4`),
    'ç”Ÿæ°”': createVideoElement(`${API_BASE}/videos/ç”Ÿæ°”çš„è¯´.mp4`),
    'default': createVideoElement(`${API_BASE}/videos/å¼€å¿ƒçš„è¯´.mp4`)
};
// ä¿®æ”¹createVideoElementå‡½æ•°ï¼Œç¡®ä¿å¾ªç¯æ’­æ”¾// 2. å¢å¼ºcreateVideoElementå‡½æ•°
function createVideoElement(src) {
    const video = document.createElement('video');
    video.src = src;
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    video.preload = 'auto';
    video.style.display = 'none';

    video.onerror = (e) => {
        console.error('è§†é¢‘åŠ è½½å¤±è´¥:', src, e);
        // å¼ºåˆ¶åˆ‡æ¢åˆ°é»˜è®¤è§†é¢‘
        video.src = `${API_BASE}/videos/å¼€å¿ƒçš„è¯´.mp4`;
    };

    document.body.appendChild(video);
    return video;
}
        // æ¸²æŸ“å¾ªç¯
        function render() {
            if (!isRendering) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentVideo && currentVideo.readyState > 2) {
                // ä¿æŒè§†é¢‘æ¯”ä¾‹å±…ä¸­
                const videoRatio = currentVideo.videoWidth / currentVideo.videoHeight;
                const canvasRatio = canvas.width / canvas.height;

                let drawWidth, drawHeight, dx, dy;

                if (videoRatio > canvasRatio) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * videoRatio;
                    dx = (canvas.width - drawWidth) / 2;
                    dy = 0;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / videoRatio;
                    dx = 0;
                    dy = (canvas.height - drawHeight) / 2;
                }

                ctx.drawImage(currentVideo, dx, dy, drawWidth, drawHeight);
            }

            requestAnimationFrame(render);
        }

        // åˆ‡æ¢è§†é¢‘
    // 1. ä¿®å¤handleVideoReadyæœªå®šä¹‰é”™è¯¯
async function switchVideo(emotion) {
    console.log(`å°è¯•åˆ‡æ¢è§†é¢‘åˆ°æƒ…ç»ª: ${emotion}`);
    showLoading(true);

    const targetVideo = videoPool[emotion] || videoPool['default'];
    console.log('ç›®æ ‡è§†é¢‘:', targetVideo.src);

    if (currentVideo === targetVideo) {
        console.log('è§†é¢‘æœªå˜åŒ–ï¼Œæ— éœ€åˆ‡æ¢');
        showLoading(false);
        return;
    }

    // åœæ­¢å½“å‰è§†é¢‘
    if (currentVideo) {
        console.log('åœæ­¢å½“å‰è§†é¢‘:', currentVideo.src);
        currentVideo.pause();
        currentVideo.removeEventListener('canplay', currentVideo._handleVideoReady);
    }

    currentVideo = targetVideo;
    currentVideo.loop = true;
    console.log('è®¾ç½®æ–°è§†é¢‘:', currentVideo.src);

    // ç­‰å¾…è§†é¢‘å‡†å¤‡å°±ç»ª
    try {
        await new Promise((resolve, reject) => {
            currentVideo._handleVideoReady = () => {
                currentVideo.removeEventListener('canplay', currentVideo._handleVideoReady);
                console.log('è§†é¢‘å‡†å¤‡å°±ç»ª');
                resolve();
            };

            currentVideo._handleError = () => {
                console.error('è§†é¢‘å‡†å¤‡å‡ºé”™');
                reject(new Error('è§†é¢‘å‡†å¤‡å¤±è´¥'));
            };

            if (currentVideo.readyState > 2) {
                resolve();
            } else {
                currentVideo.addEventListener('canplay', currentVideo._handleVideoReady);
                currentVideo.addEventListener('error', currentVideo._handleError);
            }
        });

        // è®¾ç½®Canvaså°ºå¯¸
        console.log('è§†é¢‘å°ºå¯¸:', currentVideo.videoWidth, currentVideo.videoHeight);
        canvas.width = currentVideo.videoWidth;
        canvas.height = currentVideo.videoHeight;

        await currentVideo.play();
        console.log('è§†é¢‘æ’­æ”¾æˆåŠŸ');

        if (!isRendering) {
            isRendering = true;
            render();
        }
    } catch (error) {
        console.error('è§†é¢‘åˆ‡æ¢å¤±è´¥:', error);
        // å›é€€åˆ°é»˜è®¤è§†é¢‘
        await switchVideo('default');
    } finally {
        showLoading(false);
    }
}


        // èŠå¤©è®°å½•åŠŸèƒ½
    // 4. ä¿®æ”¹é‡æ–°æ’­æ”¾æŒ‰é’®çš„åˆ›å»º
function addMessageToHistory(text, isUser, emotion, audioUrl) {
    const chatHistory = document.getElementById('chat-history');

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;

    const header = document.createElement('div');
    header.className = 'message-header';
    header.textContent = isUser ? 'ä½ è¯´ï¼š' : `AIå›å¤ï¼ˆ${emotion}ï¼‰`;

    const content = document.createElement('div');
    content.innerHTML = formatResponse(text);

    if (!isUser) {
        const replayButton = document.createElement('button');
        replayButton.className = 'replay-btn';
        replayButton.textContent = 'ğŸ”Š é‡æ–°æ’­æ”¾';
        replayButton.onclick = () => {
            const audioUrl = `${API_BASE}/download/tts_output.mp3?t=${Date.now()}`;
            playAudio(audioUrl);
        };
        messageDiv.appendChild(replayButton);
    }

    messageDiv.prepend(header);
    messageDiv.appendChild(content);
    chatHistory.appendChild(messageDiv);
    chatHistory.scrollTop = chatHistory.scrollHeight;
}

        function formatResponse(text) {
            return text
                .replace(/ï¼ˆ(.*?)ï¼‰/g, '<span style="color:#888;font-size:0.9em">$1</span>')
                .replace(/â€¦/g, 'â‹¯')
                .replace(/(\S)(~)/g, '$1<span style="color:#ff69b4;">$2</span>');
        }

        // å½•éŸ³æ§åˆ¶
        let mediaRecorder, audioChunks = [];
        const recordButton = document.getElementById('record-button');

        async function setupRecorder() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm',
                    audioBitsPerSecond: 16000
                });

                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = handleAudioStop;

                // æŒ‰é’®æ§åˆ¶
                recordButton.addEventListener('mousedown', startRecording);
                recordButton.addEventListener('mouseup', stopRecording);
                recordButton.addEventListener('touchstart', e => {
                    e.preventDefault();
                    startRecording();
                });
                recordButton.addEventListener('touchend', stopRecording);
            } catch (error) {
                alert('è¯·å…è®¸éº¦å…‹é£è®¿é—®æƒé™');
                console.error('å½•éŸ³åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        function startRecording() {
            if (!mediaRecorder) return;

            audioChunks = [];
            mediaRecorder.start();
            document.body.classList.add('recording');
            recordButton.textContent = 'æ¾å¼€ç»“æŸ';
            startTimer();
        }

        function stopRecording() {
            if (mediaRecorder?.state === 'recording') {
                mediaRecorder.stop();
                document.body.classList.remove('recording');
                recordButton.textContent = 'æŒ‰ä½å½•éŸ³';
                stopTimer();
            }
        }

        // è®¡æ—¶å™¨æ§åˆ¶
        let timerInterval;
        function startTimer() {
            let seconds = 0;
            document.querySelector('.timer').textContent = '00:00';
            timerInterval = setInterval(() => {
                seconds++;
                const m = String(Math.floor(seconds/60)).padStart(2,'0');
                const s = String(seconds%60).padStart(2,'0');
                document.querySelector('.timer').textContent = `${m}:${s}`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            document.querySelector('.timer').textContent = '00:00';
        }

        // éŸ³é¢‘å¤„ç†
        async function handleAudioStop() {
            showLoading(true);

            try {
                const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const wavBlob = await convertToWav(webmBlob);
                await uploadAudio(wavBlob);
            } catch (error) {
                console.error('éŸ³é¢‘å¤„ç†å¤±è´¥:', error);
                addMessageToHistory('å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•', false, 'default', '');
            }
            showLoading(false);
        }

        async function convertToWav(webmBlob) {
            const audioContext = new AudioContext();
            const arrayBuffer = await webmBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            const offlineContext = new OfflineAudioContext(
                1,
                audioBuffer.duration * 16000,
                16000
            );

            const source = offlineContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(offlineContext.destination);
            source.start();

            const resampled = await offlineContext.startRendering();

            // åˆ›å»ºWAVæ–‡ä»¶å¤´
            const wavHeader = new DataView(new ArrayBuffer(44));
            writeString(wavHeader, 0, 'RIFF');
            wavHeader.setUint32(4, 36 + resampled.length * 2, true);
            writeString(wavHeader, 8, 'WAVE');
            writeString(wavHeader, 12, 'fmt ');
            wavHeader.setUint32(16, 16, true);
            wavHeader.setUint16(20, 1, true);
            wavHeader.setUint16(22, 1, true);
            wavHeader.setUint32(24, 16000, true);
            wavHeader.setUint32(28, 32000, true);
            wavHeader.setUint16(32, 2, true);
            wavHeader.setUint16(34, 16, true);
            writeString(wavHeader, 36, 'data');
            wavHeader.setUint32(40, resampled.length * 2, true);

            // åˆå¹¶æ•°æ®
            const wavBuffer = new Uint8Array(44 + resampled.length * 2);
            wavBuffer.set(new Uint8Array(wavHeader.buffer), 0);

            const channelData = resampled.getChannelData(0);
            for (let i = 0; i < channelData.length; i++) {
                const value = Math.max(-1, Math.min(1, channelData[i]));
                const intValue = value < 0 ? value * 32768 : value * 32767;
                wavBuffer[44 + i*2] = intValue;
                wavBuffer[45 + i*2] = intValue >> 8;
            }

            return new Blob([wavBuffer], { type: 'audio/wav' });
        }
async function uploadAudio(wavBlob) {
    const formData = new FormData();
    formData.append('audio', wavBlob, 'recording.wav');

    try {
        // ç¡®ä¿ä½¿ç”¨å·²å®šä¹‰çš„ API_BASE
        const response = await fetch(`${API_BASE}/process`, {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        handleResponse(data);
    } catch (error) {
        console.error('ä¸Šä¼ å¤±è´¥:', error);
        addMessageToHistory('æœåŠ¡æš‚æ—¶ä¸å¯ç”¨', false, 'default', '');
    }
}

        // å“åº”å¤„ç†
// 3. ä¿®æ”¹handleResponseå‡½æ•°
function handleResponse(data) {
    addMessageToHistory(data.text, true);
    addMessageToHistory(data.raw_response, false, data.emotion, data.audio_url);

    // ä½¿ç”¨ playAudio å‡½æ•°æ’­æ”¾éŸ³é¢‘
    const audioUrl = data.audio_url.startsWith('http')
        ? data.audio_url
        : `${API_BASE}${data.audio_url}`;

    const audio = playAudio(audioUrl);

    // åˆ‡æ¢å¯¹åº”æƒ…ç»ªçš„è§†é¢‘
    switchVideo(data.emotion);

    // éŸ³é¢‘ç»“æŸååˆ‡æ¢å›é»˜è®¤è§†é¢‘
    audio.onended = () => {
        switchVideo('default');
    };
}

function playAudio(url) {
    // ä½¿ç”¨å·²å®šä¹‰çš„ API_BASE æ„å»ºå®Œæ•´ URL
    const fullUrl = url.startsWith('http') ? url : `${API_BASE}${url}`;
    const audio = new Audio(fullUrl);

    audio.play().catch(e => {
        console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®');
    });
    return audio;
}

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'flex' : 'none';
        }

        // åˆå§‹åŒ–
        Promise.all([
            new Promise(resolve => {
                Object.values(videoPool).forEach(video => {
                    if (video.readyState === 4) return;
                    video.addEventListener('loadeddata', resolve);
                });
            }),
            setupRecorder()
        ]).then(() => {
            canvas.width = videoPool.default.videoWidth;
            canvas.height = videoPool.default.videoHeight;
            switchVideo('default');
        });
    </script>
</body>
</html>